{"version":3,"sources":["assets/walls.gif","assets/nodes.gif","logo.svg","assets/algorithms.png","assets/rocket.png","assets/AtoB.png","PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/astar.js","maze-algorithms/randomMaze.js","dialog/Dialog.js","PathfindingVisualizer/PathfindingVisualizer.jsx","algorithms/bfs.js","algorithms/dfs.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","props","state","this","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","col","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","nodesToAnimate","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodeByDistance","closestNode","shift","Infinity","isVisited","updateNeighbours","sort","nodeA","nodeB","neighbours","filter","neighbour","getNeighbours","previousNode","randomMaze","walls","Math","random","dialogStyles","width","maxWidth","margin","position","left","top","transform","zIndex","backgroundColor","padding","borderRadius","display","flexDirection","dialogCloseButtonStyles","marginBottom","cursor","border","height","fontWeight","alignSelf","center","marginLeft","marginRight","Dialog","number","setState","onClose","dialog","style","onClick","src","alt","dialog2","closeModal","dialog3","dialog4","dialog5","dialog6","modalIsOpen","PathfindingVisualizer","mouseIsPressed","isRunning","isStartNode","isFinishNode","isWalNode","currRow","currCol","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","startNode_Pos","finishNode_Pos","getInitialGrid","currentRow","createNode","distanceToFinishNode","abs","isVisisted","isWallNode","generateRandomMaze","console","log","animateWalls","i","setTimeout","newGrid","getNewGridWithMaze","wall","document","getElementById","slice","nodeClassName","isNode","clearPaths","getNewGridWithWallToggled","nodesInShortestPathOrder","animateShortestPath","algorithm","nextNodesStack","currentNode","nextNode","bfs","pop","dfs","endNode","gScore","hScore","fScore","openSet","lowestIndex","current","splice","neighbors","n","neighbor","tempGScore","includes","astar","unshift","getNodesInShortestPathOrder","animateAlgorithm","e","visualizeAlgorithm","clearWalls","onMouseLeave","handleMouseLeave","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","newNode","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.919ea447.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/walls.e6dda108.gif\";","module.exports = __webpack_public_path__ + \"static/media/nodes.43ea7f11.gif\";","module.exports = __webpack_public_path__ + \"static/media/logo.ee7cd8ed.svg\";","module.exports = \"data:image/png;base64,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\"","module.exports = __webpack_public_path__ + \"static/media/rocket.ea283f8f.png\";","module.exports = __webpack_public_path__ + \"static/media/AtoB.ae4df330.png\";","import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nclass Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  render() {\r\n    const {\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n      col,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n        ? \"node-start\"\r\n        : isWall\r\n          ? \"node-wall\"\r\n          : \"\";\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp(row, col)}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Node;\r\n","export function dijkstra(grid, startNode, finishNode, nodesToAnimate) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodeByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // if we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n    // if the closest node is at a distance of infinity,\r\n    // we must be trapped, therefore should stop\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateNeighbours(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodeByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateNeighbours(node, grid) {\r\n  const neighbours = getNeighbours(node, grid);\r\n  for (const neighbour of neighbours) {\r\n    neighbour.distance = node.distance + 1;\r\n    neighbour.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n  const neighbours = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbours.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col > 0) neighbours.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n","export function astar(grid, startNode, endNode) {\r\n    // f(n) = g(n) + h(n)\r\n    startNode.gScore = 0;\r\n    startNode.hScore = 0;\r\n    startNode.fScore = 0;\r\n\r\n    const openSet = [startNode];\r\n    const visitedNodesInOrder = [startNode];\r\n\r\n    while (openSet.length) {\r\n        let lowestIndex = 0;\r\n        for (let i = 1; i < openSet.length; i++) {\r\n            if (openSet[lowestIndex].fScore > openSet[i].fScore) {\r\n                lowestIndex = i;\r\n            }\r\n        }\r\n        const current = openSet[lowestIndex];\r\n        if (current === endNode) {\r\n            visitedNodesInOrder.push(current);\r\n            break;\r\n        }\r\n\r\n        openSet.splice(lowestIndex, 1);\r\n        visitedNodesInOrder.push(current);\r\n        current.isVisited = true;\r\n\r\n        let neighbors = getNeighbours(current, grid);\r\n        neighbors = neighbors.filter((n) => !n.isWall);\r\n        for (let i = 0; i < neighbors.length; i++) {\r\n            const neighbor = neighbors[i];\r\n            const tempGScore = current.gScore + 1;\r\n            if (openSet.includes(neighbor)) {\r\n                if (tempGScore < neighbor.gScore) {\r\n                    neighbor.gScore = tempGScore;\r\n                }\r\n            } else {\r\n                neighbor.gScore = tempGScore;\r\n                openSet.push(neighbor);\r\n            }\r\n\r\n            neighbor.hScore = heuristic(neighbor, endNode);\r\n            neighbor.fScore = neighbor.gScore + neighbor.hScore;\r\n            neighbor.previousNode = current;\r\n        }\r\n    }\r\n\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n    const neighbours = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbours.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n    if (col > 0) neighbours.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n    return neighbours.filter((neighbour) => !neighbour.isVisited);\r\n}\r\n\r\n\r\nfunction heuristic(nodeA, nodeB) {\r\n    // find the manhattan distance\r\n    return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col)\r\n}","// a random maze generator\r\n// gets the grid, start and finish node\r\n// it just uses a random func to decide\r\n// when to push the wall into grid\r\nexport function randomMaze(grid, startNode, finishNode) {\r\n  let walls = [];\r\n  for (let row = 0; row < grid.length; row++) {\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      // skip if it's the start or finish node\r\n      if (\r\n        (row === startNode.row && col === startNode.col) ||\r\n        (row === finishNode.row && col === finishNode.col)\r\n      ) {\r\n        continue;\r\n      }\r\n      // random func to make decision to push the wall into the grid\r\n      if (Math.random() < 0.33) {\r\n        walls.push([row, col]);\r\n      }\r\n    }\r\n  }\r\n  // to jumble up the order in which the walls are animated,\r\n  // to make it look random\r\n  walls.sort(() => Math.random() - 0.5);\r\n  return walls;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport \"./Dialog.css\";\r\nimport walls from \"../assets/walls.gif\";\r\nimport algorithms from \"../assets/algorithms.png\";\r\nimport nodes from \"../assets/nodes.gif\";\r\nimport rocket from \"../assets/rocket.png\";\r\nimport desination from \"../assets/AtoB.png\";\r\n\r\nlet dialogStyles = {\r\n  width: \"500px\",\r\n  maxWidth: \"100%\",\r\n  margin: \"0 auto\",\r\n  position: \"fixed\",\r\n  left: \"50%\",\r\n  top: \"50%\",\r\n  transform: \"translate(-50%, -50%)\",\r\n  zIndex: \"999\",\r\n  backgroundColor: \"#eee\",\r\n  padding: \"10px 20px 40px\",\r\n  borderRadius: \"8px\",\r\n  display: \"flex\",\r\n  flexDirection: \"column\",\r\n};\r\n\r\nlet dialogCloseButtonStyles = {\r\n  marginBottom: \"15px\",\r\n  backgroundColor: \"#CBCBCB\",\r\n  padding: \"3px 8px\",\r\n  cursor: \"pointer\",\r\n  borderRadius: \"50%\",\r\n  border: \"none\",\r\n  width: \"30px\",\r\n  height: \"30px\",\r\n  fontWeight: \"bold\",\r\n  alignSelf: \"flex-end\",\r\n};\r\n\r\nlet center = {\r\n  display: \"block\",\r\n  marginLeft: \"auto\",\r\n  marginRight: \"auto\",\r\n};\r\n\r\nclass Dialog extends Component {\r\n  state = {\r\n    number: 1,\r\n  };\r\n\r\n  closeModal() {\r\n    this.setState({ number: 1 });\r\n    this.props.onClose();\r\n  }\r\n\r\n  render() {\r\n    // console.log(this.state.number)\r\n    let dialog = (\r\n      <div className=\"dialog\" style={dialogStyles}>\r\n        <button style={dialogCloseButtonStyles} onClick={this.props.onClose}>\r\n          &times;\r\n        </button>\r\n        <h1>Welcome to Pathfinding Visualizer!</h1>\r\n        <img\r\n          style={center}\r\n          id=\"size-3\"\r\n          src=\"https://raw.githubusercontent.com/Jonnylie/Pathfinding-Visualizer/master/src/assets/rocket.png\"\r\n          alt=\"rocket\"\r\n        />\r\n        <br />\r\n        <p className=\"subtitle\">\r\n          This tutorial will guide you through all of the features of this\r\n          application.\r\n        </p>\r\n        <br />\r\n        <p>if you want to skip, you can press \"X\" button to exit.</p>\r\n        <button\r\n          className=\"btn btn-primary\"\r\n          onClick={() => this.setState({ number: 2 })}\r\n        >\r\n          Next\r\n        </button>\r\n      </div>\r\n    );\r\n\r\n    let dialog2 = (\r\n      <div className=\"dialog\" style={dialogStyles}>\r\n        <button\r\n          style={dialogCloseButtonStyles}\r\n          onClick={() => this.closeModal()}\r\n        >\r\n          &times;\r\n        </button>\r\n        <h1>Do you know what is a pathfinding algorithm?</h1>\r\n        <img\r\n          style={center}\r\n          id=\"size-4\"\r\n          src=\"https://raw.githubusercontent.com/Jonnylie/Pathfinding-Visualizer/master/src/assets/AtoB.png\"\r\n          alt=\"destination\"\r\n        />\r\n        <br />\r\n        <p className=\"subtitle\">\r\n          A pathfinding algorithm is used to find the shortest path between two\r\n          points (start point and end point). This application visualize various\r\n          pathfinding algorithms in action.\r\n        </p>\r\n        <button\r\n          className=\"btn btn-primary\"\r\n          onClick={() => this.setState({ number: 3 })}\r\n        >\r\n          Next\r\n        </button>\r\n      </div>\r\n    );\r\n\r\n    let dialog3 = (\r\n      <div className=\"dialog\" style={dialogStyles}>\r\n        <button\r\n          style={dialogCloseButtonStyles}\r\n          onClick={() => this.closeModal()}\r\n        >\r\n          &times;\r\n        </button>\r\n        <h1>Adding walls</h1>\r\n        <br />\r\n        <p className=\"subtitle\">\r\n          Click on the grid to add a wall or click and drag to add walls\r\n        </p>\r\n        <br />\r\n        <p>\r\n          Walls are impenetrable, meaning that a path cannot cross through them.\r\n        </p>\r\n        <img style={center} id=\"size-1\" src={walls} alt=\"walls\" />\r\n        <button\r\n          className=\"btn btn-primary\"\r\n          onClick={() => this.setState({ number: 4 })}\r\n        >\r\n          Next\r\n        </button>\r\n      </div>\r\n    );\r\n\r\n    let dialog4 = (\r\n      <div className=\"dialog\" style={dialogStyles}>\r\n        <button\r\n          style={dialogCloseButtonStyles}\r\n          onClick={() => this.closeModal()}\r\n        >\r\n          &times;\r\n        </button>\r\n        <h1>Dragging nodes</h1>\r\n        <br />\r\n        <p className=\"subtitle\">\r\n          Click and drag the start and end node to move them\r\n        </p>\r\n        <br />\r\n        <img style={center} id=\"size-1\" src={nodes} alt=\"nodes\" />\r\n        {/* <p>Walls are impenetrable, meaning that a path cannot cross through them.</p>\r\n                <img style={center} src={walls} alt=\"walls\" /> */}\r\n        <button\r\n          className=\"btn btn-primary\"\r\n          onClick={() => this.setState({ number: 5 })}\r\n        >\r\n          Next\r\n        </button>\r\n      </div>\r\n    );\r\n\r\n    let dialog5 = (\r\n      <div className=\"dialog\" style={dialogStyles}>\r\n        <button\r\n          style={dialogCloseButtonStyles}\r\n          onClick={() => this.closeModal()}\r\n        >\r\n          &times;\r\n        </button>\r\n        <h1>Visualizing and more</h1>\r\n        <br />\r\n        <p className=\"subtitle\">\r\n          Click the buttons to visualize algorithms and do other thing\r\n        </p>\r\n        <br />\r\n        <p>\r\n          You can clear the current path and clear walls from the navbar. If you\r\n          want to access this tutorial again, click on \"Pathfinding Visualizer\"\r\n          in the top left corner of your screen.\r\n        </p>\r\n        <img\r\n          style={center}\r\n          id=\"size-2\"\r\n          src=\"https://raw.githubusercontent.com/Jonnylie/Pathfinding-Visualizer/master/src/assets/algorithms.PNG\"\r\n          alt=\"algorithms\"\r\n        />\r\n        <br />\r\n        <button\r\n          className=\"btn btn-primary\"\r\n          onClick={() => this.setState({ number: 6 })}\r\n        >\r\n          Next\r\n        </button>\r\n      </div>\r\n    );\r\n\r\n    let dialog6 = (\r\n      <div className=\"dialog\" style={dialogStyles}>\r\n        <button\r\n          style={dialogCloseButtonStyles}\r\n          onClick={() => this.closeModal()}\r\n        >\r\n          &times;\r\n        </button>\r\n        <h1>Get to know the algorithms</h1>\r\n        <br />\r\n        <p className=\"subtitle\">Not all algorithms are created equal.</p>\r\n        <br />\r\n        <p>\r\n          <strong>Dijkstra's Algorithm</strong>: the father of pathfinding\r\n          algorithms; guarantees the shortest path\r\n        </p>\r\n        <p>\r\n          <strong>Breath-first Search</strong>: a great algorithm; guarantees\r\n          the shortest path\r\n        </p>\r\n        <p>\r\n          <strong>Depth-first Search</strong>: a very bad algorithm for\r\n          pathfinding; does not guarantee the shortest path\r\n        </p>\r\n        <p>\r\n          <strong>A* Search</strong>: arguably the best pathfinding algorithm;\r\n          uses heuristics to guarantee the shortest path much faster than\r\n          Dijkstra's Algorithm\r\n        </p>\r\n        {/* <img style={center} src={walls} alt=\"walls\" /> */}\r\n        <button className=\"btn btn-primary\" onClick={() => this.closeModal()}>\r\n          Finish\r\n        </button>\r\n      </div>\r\n    );\r\n\r\n    if (!this.props.modalIsOpen) {\r\n      dialog = null;\r\n    }\r\n\r\n    if (this.props.modalIsOpen && this.state.number === 1) {\r\n      return <div>{dialog}</div>;\r\n    } else if (this.props.modalIsOpen && this.state.number === 2) {\r\n      return <div>{dialog2}</div>;\r\n    } else if (this.props.modalIsOpen && this.state.number === 3) {\r\n      return <div>{dialog3}</div>;\r\n    } else if (this.props.modalIsOpen && this.state.number === 4) {\r\n      return <div>{dialog4}</div>;\r\n    } else if (this.props.modalIsOpen && this.state.number === 5) {\r\n      return <div>{dialog5}</div>;\r\n    } else if (this.props.modalIsOpen && this.state.number === 6) {\r\n      return <div>{dialog6}</div>;\r\n    } else {\r\n      return <div></div>;\r\n    }\r\n  }\r\n}\r\n\r\nexport default Dialog;\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport { dijkstra } from \"../algorithms/dijkstra\";\r\nimport { bfs } from \"../algorithms/bfs\";\r\nimport { dfs } from \"../algorithms/dfs\";\r\nimport { astar } from \"../algorithms/astar\";\r\nimport { randomMaze } from \"../maze-algorithms/randomMaze\";\r\nimport Dialog from \"../dialog/Dialog\";\r\n\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\nclass PathfindingVisualizer extends Component {\r\n  state = {\r\n    grid: [],\r\n    mouseIsPressed: false,\r\n    isRunning: false,\r\n    isStartNode: false,\r\n    isFinishNode: false,\r\n    isWalNode: false,\r\n    currRow: 0,\r\n    currCol: 0,\r\n    START_NODE_ROW: 10,\r\n    START_NODE_COL: 10,\r\n    FINISH_NODE_ROW: 10,\r\n    FINISH_NODE_COL: 30,\r\n    startNode_Pos: [],\r\n    finishNode_Pos: [],\r\n    previousNode: false,\r\n    modalIsOpen: true,\r\n  };\r\n\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({ grid });\r\n  }\r\n\r\n  isRunning() {\r\n    this.setState({ isRunning: !this.state.isRunning });\r\n  }\r\n\r\n  getInitialGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < 20; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < 40; col++) {\r\n        currentRow.push(this.createNode(col, row));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  createNode = (col, row) => {\r\n    return {\r\n      col,\r\n      row,\r\n      isStart:\r\n        row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n      isFinish:\r\n        row === this.state.FINISH_NODE_ROW &&\r\n        col === this.state.FINISH_NODE_COL,\r\n      distance: Infinity,\r\n      distanceToFinishNode:\r\n        Math.abs(this.state.FINISH_NODE_ROW - row) +\r\n        Math.abs(this.state.FINISH_NODE_COL - col),\r\n      isVisisted: false,\r\n      isWallNode: false,\r\n      previousNode: null,\r\n    };\r\n  };\r\n\r\n  clearWalls() {\r\n    if (!this.state.isRunning && !this.state.modalIsOpen) {\r\n      const newGrid = this.state.grid.slice();\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          ).className;\r\n          if (nodeClassName === \"node node-wall\") {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node\";\r\n            node.isWall = false;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  clearPaths() {\r\n    if (!this.state.isRunning && !this.state.modalIsOpen) {\r\n      const newGrid = this.state.grid.slice();\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          ).className;\r\n          if (\r\n            nodeClassName !== \"node node-start\" &&\r\n            nodeClassName !== \"node node-finish\" &&\r\n            nodeClassName !== \"node node-wall\"\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node\";\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\r\n          }\r\n          if (nodeClassName === \"node node-finish\") {\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode = 0;\r\n          }\r\n          if (nodeClassName === \"node node-start\") {\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\r\n            node.isStart = true;\r\n            node.isWall = false;\r\n            node.previousNode = null;\r\n            node.isNode = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    this.clearPaths();\r\n    if (!this.state.isRunning && !this.state.modalIsOpen) {\r\n      if (\r\n        document.getElementById(`node-${row}-${col}`).className ===\r\n        \"node node-start\"\r\n      ) {\r\n        this.setState({\r\n          mouseIsPressed: true,\r\n          isStartNode: true,\r\n          currRow: row,\r\n          currCol: col,\r\n        });\r\n      } else if (\r\n        document.getElementById(`node-${row}-${col}`).className ===\r\n        \"node node-finish\"\r\n      ) {\r\n        this.setState({\r\n          mouseIsPressed: true,\r\n          isFinishNode: true,\r\n          currRow: row,\r\n          currCol: col,\r\n        });\r\n      } else {\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({\r\n          grid: newGrid,\r\n          mouseIsPressed: true,\r\n          isWallNode: true,\r\n          currRow: row,\r\n          currCol: col,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.isRunning && !this.state.modalIsOpen) {\r\n      if (this.state.mouseIsPressed) {\r\n        const nodeClassName = document.getElementById(`node-${row}-${col}`)\r\n          .className;\r\n        if (this.state.isStartNode) {\r\n          if (nodeClassName !== \"node node-wall\") {\r\n            const prevStartNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ];\r\n            prevStartNode.isStart = false;\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`\r\n            ).className = \"node\";\r\n            this.setState({ currRow: row, currCol: col });\r\n            const currStartNode = this.state.grid[row][col];\r\n            currStartNode.isStart = true;\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              \"node node-start\";\r\n          }\r\n          this.setState({ START_NODE_ROW: row, START_NODE_COL: col });\r\n        } else if (this.state.isFinishNode) {\r\n          if (nodeClassName !== \"node node-wall\") {\r\n            const prevFinishNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ];\r\n            prevFinishNode.isFinish = false;\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`\r\n            ).className = \"node\";\r\n            this.setState({ currRow: row, currCol: col });\r\n            const currFinishNode = this.state.grid[row][col];\r\n            currFinishNode.isFinish = true;\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              \"node node-finish\";\r\n          }\r\n          this.setState({ FINISH_NODE_ROW: row, FINISH_NODE_COL: col });\r\n        } else if (this.state.isWallNode) {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n          this.setState({ grid: newGrid });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseUp(row, col) {\r\n    if (!this.state.isRunning && !this.state.modalIsOpen) {\r\n      this.setState({ mouseIsPressed: false });\r\n      if (this.state.isStartNode) {\r\n        const isStartNode = !this.state.isStartNode;\r\n        this.setState({\r\n          isStartNode,\r\n          START_NODE_ROW: row,\r\n          START_NODE_COL: col,\r\n        });\r\n      } else if (this.state.isFinishNode) {\r\n        const isFinishNode = !this.state.isFinishNode;\r\n        this.setState({\r\n          isFinishNode,\r\n          FINISH_NODE_ROW: row,\r\n          FINISH_NODE_COL: col,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseLeave() {\r\n    if (this.state.isStartNode) {\r\n      const isStartNode = !this.state.isStartNode;\r\n      this.setState({ isStartNode, mouseIsPressed: false });\r\n    } else if (this.state.isFinishNode) {\r\n      const isFinishNode = !this.state.isFinishNode;\r\n      this.setState({ isFinishNode, mouseIsPressed: false });\r\n    } else if (this.state.isWallNode) {\r\n      const isWallNode = !this.state.isWallNode;\r\n      this.setState({ isWallNode, mouseIsPressed: false });\r\n      this.getInitialGrid();\r\n    }\r\n  }\r\n\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`\r\n        ).className;\r\n        if (\r\n          nodeClassName !== \"node node-start\" &&\r\n          nodeClassName !== \"node node-finish\"\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visited\";\r\n        }\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      if (nodesInShortestPathOrder[i] === \"last\") {\r\n        setTimeout(() => {\r\n          this.isRunning();\r\n        }, i * 50);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n          const nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          ).className;\r\n          if (\r\n            nodeClassName !== \"node node-start\" &&\r\n            nodeClassName !== \"node node-finish\"\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-shortest-path\";\r\n          }\r\n        }, 50 * i);\r\n      }\r\n    }\r\n  }\r\n\r\n  visualizeAlgorithm(algorithm) {\r\n    if (!this.state.isRunning && !this.state.modalIsOpen) {\r\n      this.isRunning();\r\n      const { grid } = this.state;\r\n      let visitedNodesInOrder;\r\n      const startNode =\r\n        grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n      const finishNode =\r\n        grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n      switch (algorithm) {\r\n        case \"Dijkstra\":\r\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n          break;\r\n        case \"Breadth-first Search\":\r\n          visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n          break;\r\n        case \"Depth-first Search\":\r\n          visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n          break;\r\n        case \"A*\":\r\n          visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      nodesInShortestPathOrder.push(\"last\");\r\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n  }\r\n\r\n  /*----------------------------------------------------------maze generations functions---------------------------------------------------------*/\r\n  generateRandomMaze = () => {\r\n    if (this.state.isRunning) return;\r\n    this.setState({ isRunning: true });\r\n    const {\r\n      grid,\r\n      START_NODE_ROW,\r\n      START_NODE_COL,\r\n      FINISH_NODE_ROW,\r\n      FINISH_NODE_COL,\r\n    } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    console.log(startNode);\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const walls = randomMaze(grid, startNode, finishNode);\r\n    this.animateWalls(walls, grid);\r\n  };\r\n\r\n  animateWalls = (walls, grid) => {\r\n    for (let i = 0; i <= walls.length; i++) {\r\n      if (i === walls.length) {\r\n        setTimeout(() => {\r\n          const newGrid = getNewGridWithMaze(this.state.grid, walls);\r\n          this.setState({ grid: newGrid, isRunning: false });\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const wall = walls[i];\r\n        const node = grid[wall[0]][wall[1]];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-animated-wall\";\r\n      }, 10 * i);\r\n    }\r\n  };\r\n\r\n  /*------------------------------------------------------------------------------------------------------------------------------*/\r\n\r\n  render() {\r\n    const { grid, mouseIsPressed } = this.state;\r\n    // console.log(grid);\r\n\r\n    return (\r\n      <>\r\n        <div>\r\n          <nav className=\"navbar navbar-expand-lg navbar-dark bg-dark\">\r\n            <button\r\n              className=\"title\"\r\n              onClick={(e) => this.setState({ modalIsOpen: true })}\r\n            >\r\n              Pathfinding Visualizer\r\n            </button>\r\n          </nav>\r\n          <div className=\"action\">\r\n            <Dialog\r\n              modalIsOpen={this.state.modalIsOpen}\r\n              onClose={() => this.setState({ modalIsOpen: false })}\r\n            ></Dialog>\r\n            <button\r\n              className=\"btn btn-primary\"\r\n              onClick={() => {\r\n                this.clearPaths();\r\n                this.visualizeAlgorithm(\"Dijkstra\");\r\n              }}\r\n            >\r\n              Dijkstra's Algorithm\r\n            </button>\r\n            <button\r\n              className=\"btn btn-primary\"\r\n              onClick={() => {\r\n                this.clearPaths();\r\n                this.visualizeAlgorithm(\"Depth-first Search\");\r\n              }}\r\n            >\r\n              Depth-first Search\r\n            </button>\r\n            <button\r\n              className=\"btn btn-primary\"\r\n              onClick={() => {\r\n                this.clearPaths();\r\n                this.visualizeAlgorithm(\"A*\");\r\n              }}\r\n            >\r\n              A* Search\r\n            </button>\r\n            <button\r\n              className=\"btn btn-primary\"\r\n              onClick={() => {\r\n                this.clearPaths();\r\n                this.visualizeAlgorithm(\"Breadth-first Search\");\r\n              }}\r\n            >\r\n              Breadth-first Search\r\n            </button>\r\n            <button\r\n              className=\"btn btn-secondary\"\r\n              onClick={() => {\r\n                this.clearPaths();\r\n                this.clearWalls();\r\n                this.generateRandomMaze();\r\n              }}\r\n            >\r\n              Generate Random Maze\r\n            </button>\r\n            <button\r\n              className=\"btn btn-danger\"\r\n              onClick={() => this.clearWalls()}\r\n            >\r\n              Clear Walls\r\n            </button>\r\n            <button\r\n              className=\"btn btn-danger\"\r\n              onClick={() => this.clearPaths()}\r\n            >\r\n              Clear Paths\r\n            </button>\r\n          </div>\r\n          <div\r\n            className=\"grid-container\"\r\n            onMouseLeave={() => this.handleMouseLeave()}\r\n          >\r\n            <div className=\"grid\">\r\n              {grid.map((row, rowIdx) => {\r\n                return (\r\n                  <div key={rowIdx}>\r\n                    {row.map((node, nodeIdx) => {\r\n                      const {\r\n                        row,\r\n                        col,\r\n                        isStart,\r\n                        isFinish,\r\n                        isVisisted,\r\n                        isWall,\r\n                      } = node;\r\n                      return (\r\n                        <Node\r\n                          key={nodeIdx}\r\n                          col={col}\r\n                          row={row}\r\n                          isStart={isStart}\r\n                          isFinish={isFinish}\r\n                          isVisisted={isVisisted}\r\n                          isWall={isWall}\r\n                          mouseIsPressed={mouseIsPressed}\r\n                          onMouseDown={(row, col) =>\r\n                            this.handleMouseDown(row, col)\r\n                          }\r\n                          onMouseEnter={(row, col) =>\r\n                            this.handleMouseEnter(row, col)\r\n                          }\r\n                          onMouseUp={(row, col) => this.handleMouseUp(row, col)}\r\n                        ></Node>\r\n                      );\r\n                    })}\r\n                  </div>\r\n                );\r\n              })}\r\n            </div>\r\n          </div>\r\n          <div className=\"info\">\r\n            <div className=\"block\" id=\"yellow\" />\r\n            <span className=\"explanation\">: Path Node</span>\r\n            <div className=\"block\" id=\"blue\" />\r\n            <span className=\"explanation\">: Visited Node</span>\r\n            <div className=\"block\" id=\"start-node\" />\r\n            <span className=\"explanation\">: Start Node</span>\r\n            <div className=\"block\" id=\"finish-node\" />\r\n            <span className=\"explanation\">: Finish Node</span>\r\n          </div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nfunction getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\nconst getNewGridWithMaze = (grid, walls) => {\r\n  let newGrid = grid.slice();\r\n  for (let wall of walls) {\r\n    let node = grid[wall[0]][wall[1]];\r\n    let newNode = {\r\n      ...node,\r\n      isWall: true,\r\n    };\r\n    newGrid[wall[0]][wall[1]] = newNode;\r\n  }\r\n  return newGrid;\r\n};\r\n\r\nexport default PathfindingVisualizer;\r\n","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function bfs(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    let nextNodesStack = [startNode];\r\n    while (nextNodesStack.length) {\r\n        const currentNode = nextNodesStack.shift();\r\n        if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n        if (\r\n            !currentNode.isWall &&\r\n            (currentNode.isStart || !currentNode.isVisited)\r\n        ) {\r\n            currentNode.isVisited = true;\r\n            visitedNodesInOrder.push(currentNode);\r\n            const { col, row } = currentNode;\r\n            let nextNode;\r\n            if (row > 0) {\r\n                nextNode = grid[row - 1][col];\r\n                if (!nextNode.isVisited) {\r\n                    nextNode.previousNode = currentNode;\r\n                    nextNodesStack.push(nextNode);\r\n                }\r\n            }\r\n            if (row < grid.length - 1) {\r\n                nextNode = grid[row + 1][col];\r\n                if (!nextNode.isVisited) {\r\n                    nextNode.previousNode = currentNode;\r\n                    nextNodesStack.push(nextNode);\r\n                }\r\n            }\r\n            if (col > 0) {\r\n                nextNode = grid[row][col - 1];\r\n                if (!nextNode.isVisited) {\r\n                    nextNode.previousNode = currentNode;\r\n                    nextNodesStack.push(nextNode);\r\n                }\r\n            }\r\n            if (col < grid[0].length - 1) {\r\n                nextNode = grid[row][col + 1];\r\n                if (!nextNode.isVisited) {\r\n                    nextNode.previousNode = currentNode;\r\n                    nextNodesStack.push(nextNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dfs(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    let nextNodesStack = [startNode];\r\n    while (nextNodesStack.length) {\r\n        const currentNode = nextNodesStack.pop();\r\n        if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n        if (!currentNode.isWall && (currentNode.isStart || !currentNode.isVisited)\r\n        ) {\r\n            currentNode.isVisited = true;\r\n            visitedNodesInOrder.push(currentNode);\r\n            const { col, row } = currentNode;\r\n            let nextNode;\r\n            if (col > 0) {\r\n                nextNode = grid[row][col - 1];\r\n                if (!nextNode.isVisited) {\r\n                    nextNode.previousNode = currentNode;\r\n                    nextNodesStack.push(nextNode);\r\n                }\r\n            }\r\n            if (row < grid.length - 1) {\r\n                nextNode = grid[row + 1][col];\r\n                if (!nextNode.isVisited) {\r\n                    nextNode.previousNode = currentNode;\r\n                    nextNodesStack.push(nextNode);\r\n                }\r\n            }\r\n            if (col < grid[0].length - 1) {\r\n                nextNode = grid[row][col + 1];\r\n                if (!nextNode.isVisited) {\r\n                    nextNode.previousNode = currentNode;\r\n                    nextNodesStack.push(nextNode);\r\n                }\r\n            }\r\n\r\n            if (row > 0) {\r\n                nextNode = grid[row - 1][col];\r\n                if (!nextNode.isVisited) {\r\n                    nextNode.previousNode = currentNode;\r\n                    nextNodesStack.push(nextNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}","import React from \"react\";\r\nimport logo from \"./logo.svg\";\r\nimport \"./App.css\";\r\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <PathfindingVisualizer></PathfindingVisualizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\nimport App from \"./App\";\r\nimport \"bootstrap/dist/css/bootstrap.css\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}